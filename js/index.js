const wardData = {
  'ÂçÉ‰ª£Áî∞': { autonomy: 'Âå∫', id: 'chiyoda' },
  '‰∏≠Â§Æ': { autonomy: 'Âå∫', id: 'chuo' },
  'Ê∏Ø': { autonomy: 'Âå∫', id: 'minato' },
  'Êñ∞ÂÆø': { autonomy: 'Âå∫', id: 'shinjuku' },
  'Êñá‰∫¨': { autonomy: 'Âå∫', id: 'bunkyo' },
  'Âè∞Êù±': { autonomy: 'Âå∫', id: 'taito' },
  'Â¢®Áî∞': { autonomy: 'Âå∫', id: 'sumida' },
  'Ê±üÊù±': { autonomy: 'Âå∫', id: 'koto' },
  'ÂìÅÂ∑ù': { autonomy: 'Âå∫', id: 'shinagawa' },
  'ÁõÆÈªí': { autonomy: 'Âå∫', id: 'meguro' },
  'Â§ßÁî∞': { autonomy: 'Âå∫', id: 'ota' },
  '‰∏ñÁî∞Ë∞∑': { autonomy: 'Âå∫', id: 'setagaya' },
  'Ê∏ãË∞∑': { autonomy: 'Âå∫', id: 'shibuya' },
  '‰∏≠Èáé': { autonomy: 'Âå∫', id: 'nakano' },
  'Êùâ‰∏¶': { autonomy: 'Âå∫', id: 'suginami' },
  'Ë±äÂ≥∂': { autonomy: 'Âå∫', id: 'toshima' },
  'Âåó': { autonomy: 'Âå∫', id: 'kita' },
  'ËçíÂ∑ù': { autonomy: 'Âå∫', id: 'arakawa' },
  'ÊùøÊ©ã': { autonomy: 'Âå∫', id: 'itabashi' },
  'Á∑¥È¶¨': { autonomy: 'Âå∫', id: 'nerima' },
  'Ë∂≥Á´ã': { autonomy: 'Âå∫', id: 'adachi' },
  'ËëõÈ£æ': { autonomy: 'Âå∫', id: 'katsushika' },
  'Ê±üÊà∏Â∑ù': { autonomy: 'Âå∫', id: 'edogawa' },
  'ÂÖ´ÁéãÂ≠ê': { autonomy: 'Â∏Ç', id: 'hachioji' },
  'Á´ãÂ∑ù': { autonomy: 'Â∏Ç', id: 'tachikawa' },
  'Ê≠¶ËîµÈáé': { autonomy: 'Â∏Ç', id: 'musashino' },
  '‰∏âÈ∑π': { autonomy: 'Â∏Ç', id: 'mitaka' },
  'ÈùíÊ¢Ö': { autonomy: 'Â∏Ç', id: 'ome' },
  'Â∫ú‰∏≠': { autonomy: 'Â∏Ç', id: 'fuchu' },
  'ÈùíÊ¢Ö': { autonomy: 'Â∏Ç', id: 'ome' },
  'Êò≠Â≥∂': { autonomy: 'Â∏Ç', id: 'akishima' },
  'Ë™øÂ∏É': { autonomy: 'Â∏Ç', id: 'chofu' },
  'Áî∫Áî∞': { autonomy: 'Â∏Ç', id: 'machida' },
  'Â∞èÈáë‰∫ï': { autonomy: 'Â∏Ç', id: 'koganei' },
  'Â∞èÂπ≥': { autonomy: 'Â∏Ç', id: 'kodaira' },
  'Êó•Èáé': { autonomy: 'Â∏Ç', id: 'hino' },
  'Êù±ÊùëÂ±±': { autonomy: 'Â∏Ç', id: 'higashimurayama' },
  'ÂõΩÂàÜÂØ∫': { autonomy: 'Â∏Ç', id: 'kokubunji' },
  'ÂõΩÁ´ã': { autonomy: 'Â∏Ç', id: 'kunitachi' },
  'Á¶èÁîü': { autonomy: 'Â∏Ç', id: 'fussa' },
  'ÁãõÊ±ü': { autonomy: 'Â∏Ç', id: 'komae' },
  'Êù±Â§ßÂíå': { autonomy: 'Â∏Ç', id: 'higashiyamato' },
  'Ê∏ÖÁÄ¨': { autonomy: 'Â∏Ç', id: 'kiyose' },
  'Êù±‰πÖÁïôÁ±≥': { autonomy: 'Â∏Ç', id: 'higashikurume' },
  'Ê≠¶ËîµÊùëÂ±±': { autonomy: 'Â∏Ç', id: 'musashimurayama' },
  'Â§öÊë©': { autonomy: 'Â∏Ç', id: 'tama' },
  'Á®≤Âüé': { autonomy: 'Â∏Ç', id: 'inagi' },
  'ÁæΩÊùë': { autonomy: 'Â∏Ç', id: 'hamura' },
  '„ÅÇ„Åç„ÇãÈáé': { autonomy: 'Â∏Ç', id: 'akiruno' },
  'Ë•øÊù±‰∫¨': { autonomy: 'Â∏Ç', id: 'nishitokyo' },
  'ÁëûÁ©Ç': { autonomy: 'Áî∫', id: 'mizuho' },
  'Êó•„ÅÆÂá∫': { autonomy: 'Áî∫', id: 'hinode' },
  'Â••Â§öÊë©': { autonomy: 'Áî∫', id: 'okutama' },
  'Â§ßÂ≥∂': { autonomy: 'Áî∫', id: 'oshima' },
  'ÂÖ´‰∏à': { autonomy: 'Áî∫', id: 'hachijo' },
  'Ê™úÂéü': { autonomy: 'Êùë', id: 'hinohara' },
  'Âà©Â≥∂': { autonomy: 'Êùë', id: 'toshimamura' },
  'Êñ∞Â≥∂': { autonomy: 'Êùë', id: 'niijima' },
  'Á•ûÊ¥•Â≥∂': { autonomy: 'Êùë', id: 'kouzushima' },
  '‰∏âÂÆÖ': { autonomy: 'Êùë', id: 'miyake' },  
  'Âæ°ËîµÂ≥∂': { autonomy: 'Êùë', id: 'mikurasima' },
  'Èùí„É∂Â≥∂': { autonomy: 'Êùë', id: 'aogashima' },
  'Â∞èÁ¨†Âéü': { autonomy: 'Êùë', id: 'ogasawara' }
}

const totalLabel = 'Á¥ØË®à'
const dayLabel = 'Êó•Âà•'

const baseurl = 'https://raw.githubusercontent.com/gucchisk/parse-tokyo-covid-report-pdf'
const dataurl = 'https://raw.githubusercontent.com/tokyo-metropolitan-gov/covid19/gh-pages/data/130001_tokyo_covid19_patients.csv'

function autonomy(name) {
  const data = wardData[name]
  if (data === undefined) {
    return ''
  }
  return data.autonomy
}

function dateString(date) {
  const y = date.substring(0, 4)
  const m = date.substring(4, 6)
  const d = date.substring(6, 8)
  return [y, m, d].join('/')
}

async function getCSV(filename) {
  // let path
  // if (ENV.env === 'dev') {
  //   path = 'dev'
  // } else {
  //   path = 'csv'
  // }
  const res = await fetch(`${baseurl}/master/csv/${filename}`)
  if (!res.ok) {
    return null
  }
  const text = await res.text()
  const result = []
  const items = text.split("\n")
  const data = new Array()
  items
    .filter(item => item !== '')
    .forEach(item => {
      const arr = item.split(',')
      const ward = arr[0]
      const num = arr[1]
      data.push({ ward, num })
    })
  return data
}

async function getDataList() {
  // let path
  // if (ENV.env === 'dev') {
  //   path = 'dev'
  // } else {
  //   path = '.'
  // }
  const res = await fetch(`${baseurl}/master/list.txt`)
  if (!res.ok) {
    return null
  }
  const text = await res.text()
  return text.split("\n").filter(x => x !== "")
}

async function getCountTokyo(datestr) {
  const dateText = `${datestr.substring(0, 4)}-${datestr.substring(4, 6)}-${datestr.substring(6, 8)}`
  const res = await fetch(dataurl)
  if (!res.ok) {
    return null
  }
  const text = await res.text()
  return text.split('\n').filter(line => {
    return line.split(',')[4] == dateText
  }).length
}

async function getData(list) {
  const fetches = list.map(filename => {
    return getCSV(filename)
  })
  return Promise.all(fetches)
}

function error() {
  document.getElementById('grid-main').innerHTML = '<p class="message">„Åî„ÇÅ„Çì„Å™„Åï„ÅÑüôá‚Äç„Éá„Éº„Çø„ÅÆ„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ</p>'
}

window.onload = async () => {
  const start = new Date().getMilliseconds()
  const all = await getDataList()
  const list = [all[0], all[1]]
  if (list === null) {
    error()
    return
  }
  getCountTokyo(list[0]).then(count => {
    document.getElementById('date').innerHTML = `${dateString(list[0])} - ${count}<span>‰∫∫</span>`
  })
  const data = await getData(list)

  if (data[0] === null || data[1] === null) {
    error()
    return
  }

  let max = 0
  data[0].forEach((obj, i) => {
    if (data[0].length - 1 === i) {
      return
    }
    const current = parseInt(obj.num)
    if (current > max) {
      max = current
    }
  })

  const range = Math.floor(max / 31)
  const level1 = range
  const level2 = range * 3
  const level3 = range * 7
  const level4 = range * 15

  data[0].forEach((obj, i) => {
    const div = document.createElement('div')
    const diff = parseInt(obj.num) - parseInt(data[1][i].num)
    let diffText = ""
    if (Object.keys(wardData).includes(obj.ward)) {
      if (diff === 0) {
	diffText = "(¬±0)";
      } else {
	if (diff < 0) {
	  diffText = `(<span class="plus">${diff}</span>)`
	} else if (diff < 10) {
	  diffText = `(<span class="plus">+${diff}</span>)`
	} else {
	  diffText = `(<span class="plus emphasis">+${diff}</span>)`
	}
      }
    }
    let level = 1
    if (i < data[0].length - 2) {
      const num = parseInt(obj.num)
      if (num > level4) {
	level = 5
      } else if (num > level3) {
	level = 4
      } else if (num > level2) {
	level = 3
      } else if (num > level1) {
	level = 2
      }
    }
    div.className = `item level${level}`
    const name = obj.ward + autonomy(obj.ward)
    const wdata = wardData[obj.ward]
    let divtag = '<div>'
    if (wdata !== undefined) {
      divtag = `<div id="${wdata.id}" class="clickpop" href="#popup" data-effect="mfp-zoom-in">`
    }
    div.innerHTML = `${divtag}<p class="ward">${name}</p><p class="num">${obj.num} ${diffText}</p></div>`
    document.getElementById('grid-main').append(div)
  })

  const end = new Date().getMilliseconds()
  const timeout = (end - start) < 1000 ? 1000 - (end - start) : 0
  setTimeout(() => {
    $('.loader').removeClass('is-active')
  }, timeout)

  $('.clickpop').magnificPopup({
    removalDelay: 300,
    callbacks: {
      beforeOpen: function() {
	const el = this.st.el
	const name = el.children('.ward').text()
	$('#charttitle').html(name)
	this.st.mainClass = el.attr('data-effect')
      },
      open: async function() {
	setTimeout(async () => {
	  const el = this.st.el
	  const id = el.attr('id')
	  const name = el.children('.ward').text()
	  let x = ['x']
	  let total = [totalLabel]
	  let day = [dayLabel]
	  list.forEach((l) => {
	    x.push(`${l.substring(0, 4)}/${l.substring(4, 6)}/${l.substring(6, 8)}`)
	    total.push(0)
	    day.push(0)
	  })
	  const filename = `${id}.csv`

	  const res = await fetch(`${baseurl}/master/data/${filename}`)
	  const text = await res.text()
	  const lines = text.split('\n')
	  x = ['x']
	  total = [totalLabel]
	  day = [dayLabel, 0]
	  lines.forEach((line, index) => {
	    const datevalue = line.split(',')
	    if (datevalue[1] !== undefined) {
	      const date = datevalue[0]
	      x.push(`${date.substring(0, 4)}/${date.substring(4, 6)}/${date.substring(6, 8)}`)
	      if (index !== 0) {
		day.push(datevalue[1] - total[total.length - 1])
	      }
	      total.push(datevalue[1])
	    }
	  })
	  // this.chart.load({
	  //   columns: [
	  //     x,
	  //     day,
	  //     total
	  //   ],
	  // })
	  this.chart = c3.generate({
	    bindto: '#chart',
	    data: {
	      x: 'x',
	      hide: [totalLabel],
	      xFormat: '%Y/%m/%d',
	      columns: [
		x,
		day,
		total
	      ],
	      groups: [
		['value']
	      ],
	      type: 'bar'
	    },
	    bar: {
	      width: {
		ratio: 0.5
	      }
	    },
	    axis: {
	      x: {
		type: 'timeseries',
		tick: {
		  culling: true,
		  format: '%m/%d'
		}
	      }
	    },
	    subchart: {
	      show: true,
	    },
	    zoom: {
	      enabled: true,
	      rescale: true
	    }
	  })
	  // this.chart.zoom(['2020/10/01', x[x.length-1]])
	  const d = new Date()
	  const today = `${d.getFullYear()}/${(d.getMonth()+1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`
	  this.chart.zoom(['2020/10/01', today])
	}, 200)
      },
      close: function() {
	this.chart.unload({
	  ids: [this.st.el.children('.ward').text()]
	})
      }
    },
    midClick: true
  })
}
